diff --git a/drivers/media/i2c/imx274.c b/drivers/media/i2c/imx274.c
index 2c60402..f4eb0a2 100644
--- a/drivers/media/i2c/imx274.c
+++ b/drivers/media/i2c/imx274.c
@@ -16,6 +16,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#define DEBUG 1
 #include <linux/slab.h>
 #include <linux/uaccess.h>
 #include <linux/gpio.h>
@@ -25,7 +26,6 @@
 #include <linux/of.h>
 #include <linux/of_device.h>
 #include <linux/of_gpio.h>
-
 #include <media/tegra-v4l2-camera.h>
 #include <media/camera_common.h>
 #include <media/imx274.h>
@@ -35,10 +35,18 @@
 #define IMX274_MAX_COARSE_DIFF		10
 
 #define IMX274_GAIN_SHIFT		8
-#define IMX274_MIN_GAIN		(1 << IMX274_GAIN_SHIFT)
-#define IMX274_MAX_GAIN		(23 << IMX274_GAIN_SHIFT)
+#define IMX274_GAIN_REG_MAX			(1957)
+#define IMX274_GAIN_SHIFT_MASK			((1 << IMX274_GAIN_SHIFT) - 1)
+#define IMX274_MAX_DIGITAL_GAIN			(8)
+#define IMX274_MAX_ANALOG_GAIN			(2048 / (2048 - IMX274_GAIN_REG_MAX))
+#define IMX274_GAIN_CONST			(2048) /* for gain formula */
+
+
+
+#define IMX274_MIN_GAIN		(1)
+#define IMX274_MAX_GAIN		(180)
 #define IMX274_MIN_FRAME_LENGTH	(0x8ED)
-#define IMX274_MAX_FRAME_LENGTH	(0xFFFF)
+#define IMX274_MAX_FRAME_LENGTH	(0xB292)
 #define IMX274_MIN_EXPOSURE_COARSE	(0x0001)
 #define IMX274_MAX_EXPOSURE_COARSE	\
 	(IMX274_MAX_FRAME_LENGTH-IMX274_MAX_COARSE_DIFF)
@@ -50,13 +58,36 @@
 
 #define IMX274_DEFAULT_MODE	IMX274_MODE_3840X2160
 
-#define IMX274_DEFAULT_WIDTH	3840
-#define IMX274_DEFAULT_HEIGHT	2160
+#define IMX274_DEFAULT_WIDTH	3864
+#define IMX274_DEFAULT_HEIGHT	2174
 #define IMX274_DEFAULT_DATAFMT	MEDIA_BUS_FMT_SRGGB10_1X10
 #define IMX274_DEFAULT_CLK_FREQ	24000000
-#define IMX274_1080P_MODE_HMAX			260
-#define IMX274_1080P_MODE_MIN_VMAX		4620
-#define IMX274_1080P_MODE_OFFSET		112
+/*
+ * shift and mask constants
+ */
+#define IMX274_SHIFT_8_BITS			(8)
+#define IMX274_SHIFT_16_BITS			(16)
+#define IMX274_MASK_LSB_2_BITS			(0x03)
+#define IMX274_MASK_LSB_3_BITS			(0x07)
+#define IMX274_MASK_LSB_4_BITS			(0x0f)
+#define IMX274_MASK_LSB_8_BITS			(0x00ff)
+
+
+#define IMX274_FRAME_LENGTH_ADDR_1		0x30FA /* VMAX, MSB */
+#define IMX274_FRAME_LENGTH_ADDR_2		0x30F9 /* VMAX */
+#define IMX274_FRAME_LENGTH_ADDR_3		0x30F8 /* VMAX, LSB */
+#define IMX274_SVR_REG_MSB			0x300F /* SVR */
+#define IMX274_SVR_REG_LSB			0x300E /* SVR */
+#define IMX274_HMAX_REG_MSB			0x30F7 /* HMAX */
+#define IMX274_HMAX_REG_LSB			0x30F6 /* HMAX */
+#define IMX274_COARSE_TIME_ADDR_MSB		0x300D /* SHR */
+#define IMX274_COARSE_TIME_ADDR_LSB		0x300C /* SHR */
+#define IMX274_ANALOG_GAIN_ADDR_LSB		0x300A /* ANALOG GAIN LSB */
+#define IMX274_ANALOG_GAIN_ADDR_MSB		0x300B /* ANALOG GAIN MSB */
+#define IMX274_DIGITAL_GAIN_REG			0x3012 /* Digital Gain */
+#define IMX274_VFLIP_REG			0x301A /* VERTICAL FLIP */
+#define IMX274_STANDBY_REG			0x3000 /* STANDBY */
+
 
 struct imx274 {
 	struct camera_common_power_rail	power;
@@ -65,7 +96,8 @@ struct imx274 {
 	struct i2c_client		*i2c_client;
 	struct v4l2_subdev		*subdev;
 	struct media_pad		pad;
-	u32				vmax;
+	u32	frame_length;
+
 	s32				group_hold_prev;
 	bool				group_hold_en;
 	struct regmap			*regmap;
@@ -95,9 +127,9 @@ static struct v4l2_ctrl_config ctrl_config_list[] = {
 		.name = "Gain",
 		.type = V4L2_CTRL_TYPE_INTEGER,
 		.flags = V4L2_CTRL_FLAG_SLIDER,
-		.min = IMX274_MIN_GAIN,
-		.max = IMX274_MAX_GAIN,
-		.def = IMX274_DEFAULT_GAIN,
+		.min = IMX274_MIN_GAIN * 100,
+		.max = IMX274_MAX_GAIN * 100,
+		.def = IMX274_DEFAULT_GAIN * 100,
 		.step = 1,
 	},
 	{
@@ -161,11 +193,9 @@ static inline void imx274_get_vmax_regs(imx274_reg *regs,
 				u32 vmax)
 {
 	regs->addr = IMX274_VMAX_ADDR_MSB;
-	regs->val = (vmax >> 16) & 0x0f;
-	(regs + 1)->addr = IMX274_VMAX_ADDR_MID;
-	(regs + 1)->val = (vmax >> 8) & 0xff;
-	(regs + 2)->addr = IMX274_VMAX_ADDR_LSB;
-	(regs + 2)->val = (vmax) & 0xff;
+	regs->val = (vmax >> 8) & 0xff;
+	(regs + 1)->addr = IMX274_VMAX_ADDR_LSB;
+	(regs + 1)->val = (vmax) & 0xff;
 }
 
 static inline void imx274_get_shr_regs(imx274_reg *regs,
@@ -382,14 +412,14 @@ static int imx274_power_get(struct imx274 *priv)
 	}
 
 	/* ananlog 2.7v */
-	err |= camera_common_regulator_get(&priv->i2c_client->dev,
-			&pw->avdd, pdata->regulators.avdd);
+	//err |= camera_common_regulator_get(&priv->i2c_client->dev,
+	//		&pw->avdd, pdata->regulators.avdd);
 	/* digital 1.2v */
-	err |= camera_common_regulator_get(&priv->i2c_client->dev,
-			&pw->dvdd, pdata->regulators.dvdd);
+	//err |= camera_common_regulator_get(&priv->i2c_client->dev,
+	//		&pw->dvdd, pdata->regulators.dvdd);
 	/* IO 1.8v */
-	err |= camera_common_regulator_get(&priv->i2c_client->dev,
-			&pw->iovdd, pdata->regulators.iovdd);
+	//err |= camera_common_regulator_get(&priv->i2c_client->dev,
+	//		&pw->iovdd, pdata->regulators.iovdd);
 
 	if (!err) {
 		pw->reset_gpio = pdata->reset_gpio;
@@ -427,7 +457,7 @@ static int imx274_s_stream(struct v4l2_subdev *sd, int enable)
 		goto exit;
 
 
-	if (s_data->override_enable) {
+	//if (s_data->override_enable) {
 		/* write list of override regs for the asking frame length, */
 		/* coarse integration time, and gain.                       */
 		control.id = TEGRA_CAMERA_CID_GAIN;
@@ -450,7 +480,7 @@ static int imx274_s_stream(struct v4l2_subdev *sd, int enable)
 		if (err)
 			dev_dbg(&client->dev,
 				"%s: error coarse time override\n", __func__);
-	}
+	//}
 
 	if (test_mode) {
 		err = imx274_write_table(priv,
@@ -565,8 +595,115 @@ fail:
 	return err;
 }
 
+static inline void imx274_calculate_gain_regs(imx274_reg *regs, u16 gain)
+{
+	regs->addr = IMX274_ANALOG_GAIN_ADDR_MSB;
+	regs->val = (gain >> IMX274_SHIFT_8_BITS) & IMX274_MASK_LSB_3_BITS;
+
+	(regs + 1)->addr = IMX274_ANALOG_GAIN_ADDR_LSB;
+	(regs + 1)->val = (gain) & IMX274_MASK_LSB_8_BITS;
+}
+
+
+/*
+ * imx274_set_digital gain - Function called when setting digital gain
+ * @priv: Pointer to device structure
+ * @dgain: Value of digital gain.
+ *
+ * Digital gain has only 4 steps: 1x, 2x, 4x, and 8x
+ *
+ * Return: 0 on success
+ */
+static int imx274_set_digital_gain(struct imx274 *priv, u32 dgain)
+{
+	int ret;
+	u8 reg_val;
+
+	switch (dgain) {
+	case 1:
+		reg_val = 0;
+		break;
+	case 2:
+		reg_val = 1;
+		break;
+	case 4:
+		reg_val = 2;
+		break;
+	case 8:
+		reg_val = 3;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = imx274_write_reg(priv->s_data, IMX274_DIGITAL_GAIN_REG,
+			       reg_val & IMX274_MASK_LSB_4_BITS);
+	return ret;
+}
+
+
 static int imx274_set_gain(struct imx274 *priv, s32 val)
 {
+
+	imx274_reg reg_list[2];
+	int err;
+	u32 gain, analog_gain, digital_gain, gain_reg;
+	int i;
+
+	gain = val / 100;
+
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s : input gain = %d.%d\n", __func__,
+		 gain >> IMX274_GAIN_SHIFT,
+		 ((gain & IMX274_GAIN_SHIFT_MASK) * 100) >> IMX274_GAIN_SHIFT);
+
+	if (gain > IMX274_MAX_DIGITAL_GAIN * IMX274_MAX_ANALOG_GAIN)
+		gain = IMX274_MAX_DIGITAL_GAIN * IMX274_MAX_ANALOG_GAIN;
+	else if (gain < IMX274_MIN_GAIN)
+		gain = IMX274_MIN_GAIN;
+
+	if (gain <= IMX274_MAX_ANALOG_GAIN)
+		digital_gain = 1;
+	else if (gain <= IMX274_MAX_ANALOG_GAIN * 2)
+		digital_gain = 2;
+	else if (gain <= IMX274_MAX_ANALOG_GAIN * 4)
+		digital_gain = 4;
+	else
+		digital_gain = IMX274_MAX_DIGITAL_GAIN;
+
+	analog_gain = val / digital_gain;
+
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s : digital gain = %d, analog gain = %d\n",
+		 __func__, digital_gain, analog_gain);
+
+	err = imx274_set_digital_gain(priv, digital_gain);
+	if (err)
+		goto fail;
+
+	/* convert to register value, refer to imx274 datasheet */
+	gain_reg = (u32)IMX274_GAIN_CONST -
+		(IMX274_GAIN_CONST * 100) / analog_gain;
+	if (gain_reg > IMX274_GAIN_REG_MAX)
+		gain_reg = IMX274_GAIN_REG_MAX;
+
+	imx274_calculate_gain_regs(reg_list, (u16)gain_reg);
+
+	for (i = 0; i < ARRAY_SIZE(reg_list); i++) {
+		err = imx274_write_reg(priv->s_data, reg_list[i].addr,
+				       reg_list[i].val);
+		if (err)
+			goto fail;
+	}
+
+
+	return 0;
+
+fail:
+	return err;
+
+#if 0
+
 	imx274_reg reg_list[2];
 	int err;
 	int i = 0;
@@ -599,62 +736,46 @@ fail:
 	dev_dbg(&priv->i2c_client->dev,
 		 "%s: GAIN control error\n", __func__);
 	return err;
+#endif
 }
 
 static int imx274_set_frame_length(struct imx274 *priv, s32 val)
 {
-	struct camera_common_data *s_data = priv->s_data;
-	const struct sensor_mode_properties *mode =
-		&s_data->sensor_props.sensor_modes[s_data->mode];
-	imx274_reg reg_list[3];
+	imx274_reg reg_list[2];
 	int err;
 	u32 frame_length;
 	u32 frame_rate;
 	int i = 0;
+	u8 svr;
+	u32 vmax;
 
 	dev_dbg(&priv->i2c_client->dev,
 		 "%s: val: %u\n", __func__, val);
 
 	frame_length = (u32)val;
 
-	frame_rate = (u32)(mode->signal_properties.pixel_clock.val /
-			(u32)(frame_length *
-			mode->image_properties.line_length));
-
-	if (s_data->mode == IMX274_MODE_1920X1080) {
-		priv->vmax = (u32)(IMX274_SENSOR_INTERNAL_CLK_FREQ /
-				(frame_rate *
-				IMX274_1080P_MODE_HMAX));
-		if (priv->vmax < IMX274_1080P_MODE_MIN_VMAX)
-			priv->vmax = IMX274_1080P_MODE_MIN_VMAX;
-	} else {
-	/*For 4K mode*/
-	priv->vmax = (u32)(IMX274_SENSOR_INTERNAL_CLK_FREQ /
-			(frame_rate *
-			IMX274_4K_MODE_HMAX));
-		if (priv->vmax < IMX274_4K_MODE_MIN_VMAX)
-			priv->vmax = IMX274_4K_MODE_MIN_VMAX;
-	}
+	frame_rate = (u32)(IMX274_PIXEL_CLK_HZ /
+				(u32)(frame_length * IMX274_LINE_LENGTH));
+
+	imx274_read_reg(priv->s_data, IMX274_SVR_ADDR, &svr);
 
-	imx274_get_vmax_regs(reg_list, priv->vmax);
+	vmax = (u32)(72000000 /
+			(u32)(frame_rate * IMX274_HMAX * (svr + 1))) - 12;
+
+	imx274_get_vmax_regs(reg_list, vmax);
 
 	imx274_set_group_hold(priv);
 
-	for (i = 0; i < 3; i++) {
+	for (i = 0; i < 2; i++) {
 		err = imx274_write_reg(priv->s_data, reg_list[i].addr,
 			 reg_list[i].val);
 		if (err)
 			goto fail;
 	}
+	priv->frame_length = vmax;
 
 	dev_dbg(&priv->i2c_client->dev,
-		"%s: PCLK: %lld, FL: %d, LL: %d, fps: %d, VMAX: %d\n", __func__,
-			mode->signal_properties.pixel_clock.val,
-			frame_length,
-			mode->image_properties.line_length,
-			frame_rate,
-			priv->vmax);
-
+		"%s: frame_rate: %d vmax: %u\n", __func__, frame_rate, vmax);
 	return 0;
 
 fail:
@@ -665,54 +786,37 @@ fail:
 
 static int imx274_calculate_shr(struct imx274 *priv, u32 rep)
 {
-	const struct camera_common_data *s_data = priv->s_data;
-	const struct sensor_mode_properties *mode =
-		&s_data->sensor_props.sensor_modes[s_data->mode];
+	u8 svr;
 	int shr;
-	int shr_min;
-	int shr_max;
-	u64 et_long;
-
-	if (priv->vmax < IMX274_4K_MODE_MIN_VMAX)
-		priv->vmax = IMX274_4K_MODE_MIN_VMAX;
-
-	et_long = mode->image_properties.line_length * rep *
-		FIXED_POINT_SCALING_FACTOR /
-		mode->signal_properties.pixel_clock.val;
-
-	if (s_data->mode == IMX274_MODE_1920X1080) {
-		et_long = mode->image_properties.line_length * rep *
-			FIXED_POINT_SCALING_FACTOR /
-			mode->signal_properties.pixel_clock.val;
-
-		shr = priv->vmax  -
-			(et_long * IMX274_SENSOR_INTERNAL_CLK_FREQ /
-			FIXED_POINT_SCALING_FACTOR  -
-			IMX274_1080P_MODE_OFFSET) /
-			IMX274_1080P_MODE_HMAX;
-
-		if (shr > priv->vmax - 4)
-			shr = priv->vmax - 4;
-		if (shr < 8)
-			shr = 8;
-	} else {
-		/*For 4K mode*/
-		shr = priv->vmax -
-			(et_long * IMX274_SENSOR_INTERNAL_CLK_FREQ /
-			FIXED_POINT_SCALING_FACTOR -
-			IMX274_4K_MODE_OFFSET) /
-			IMX274_4K_MODE_HMAX;
-
-		shr_min = 12;
-		shr_max = priv->vmax - 4;
-		if (shr > shr_max)
-			shr = shr_max;
-
-		if (shr < shr_min)
-			shr = shr_min;
-	}
+	int min;
+	int max;
+	u8 vmax_l;
+	u8 vmax_m;
+	u32 vmax;
+
+	imx274_read_reg(priv->s_data, IMX274_SVR_ADDR, &svr);
+
+	imx274_read_reg(priv->s_data, IMX274_VMAX_ADDR_LSB, &vmax_l);
+	imx274_read_reg(priv->s_data, IMX274_VMAX_ADDR_MSB, &vmax_m);
+
+	vmax = ((vmax_m << 8) + vmax_l);
+
+	min = IMX274_MODE1_SHR_MIN;
+	//max = ((svr + 1) * IMX274_VMAX) - 4;
+	max = ((svr + 1) * priv->frame_length) - 4;
+
+	shr = vmax * (svr + 1) -
+			(rep * IMX274_ET_FACTOR - IMX274_MODE1_OFFSET) /
+			IMX274_HMAX;
+
+	if (shr < min)
+		shr = min;
+
+	if (shr > max)
+		shr = max;
+
 	dev_dbg(&priv->i2c_client->dev,
-		 "%s: shr: %u vmax: %d\n", __func__, shr, priv->vmax);
+		 "%s: shr: %u vmax: %d\n", __func__, shr, vmax);
 	return shr;
 }
 
@@ -862,7 +966,6 @@ error:
 }
 
 MODULE_DEVICE_TABLE(of, imx274_of_match);
-
 static struct camera_common_pdata *imx274_parse_dt(struct i2c_client *client,
 				const struct camera_common_data *s_data)
 {
@@ -941,6 +1044,7 @@ static int imx274_probe(struct i2c_client *client,
 	struct camera_common_data *common_data;
 	struct device_node *node = client->dev.of_node;
 	struct imx274 *priv;
+	char debugfs_name[10];
 	int err;
 
 	pr_info("[IMX274]: probing v4l2 sensor.\n");
@@ -1009,6 +1113,10 @@ static int imx274_probe(struct i2c_client *client,
 		dev_err(&client->dev, "Failed to initialize imx274.\n");
 		return err;
 	}
+	sprintf(debugfs_name, "imx274_%c", common_data->csi_port + 'a');
+	dev_dbg(&client->dev, "%s: name %s\n", __func__, debugfs_name);
+
+	camera_common_create_debugfs(common_data, "imx274");
 
 	v4l2_i2c_subdev_init(priv->subdev, client, &imx274_subdev_ops);
 
@@ -1084,3 +1192,4 @@ module_i2c_driver(imx274_i2c_driver);
 MODULE_DESCRIPTION("Media Controller driver for Sony IMX274");
 MODULE_AUTHOR("Josh Kuo <joshk@nvidia.com>");
 MODULE_LICENSE("GPL v2");
+
diff --git a/include/media/imx274.h b/include/media/imx274.h
index 499ce3d..4dbd68a 100644
--- a/include/media/imx274.h
+++ b/include/media/imx274.h
@@ -38,8 +38,7 @@
 #define IMX274_SHR_ADDR_MSB				0x300D
 
 #define IMX274_VMAX_ADDR_LSB			0x30F8
-#define IMX274_VMAX_ADDR_MID			0x30F9
-#define IMX274_VMAX_ADDR_MSB			0x30FA
+#define IMX274_VMAX_ADDR_MSB			0x30F9
 
 #define IMX274_GAIN_ADDR_LSB			0x300A
 #define IMX274_GAIN_ADDR_MSB			0x300B
@@ -49,10 +48,12 @@
 #define IMX274_PIXEL_CLK_HZ				756000000
 #define IMX274_LINE_LENGTH				4200
 
-#define IMX274_SENSOR_INTERNAL_CLK_FREQ		72000000
-#define IMX274_4K_MODE_HMAX			263
-#define IMX274_4K_MODE_MIN_VMAX			4550
-#define IMX274_4K_MODE_OFFSET			112
+#define IMX274_VMAX						4550
+#define IMX274_HMAX						263
+#define IMX274_MODE1_OFFSET				112
+#define IMX274_MODE1_SHR_MIN			12
+#define IMX274_ET_FACTOR				400
+
 
 struct imx274_mode {
 	__u32 xres;
